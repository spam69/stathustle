datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // For Prisma Migrate, usually same as DATABASE_URL for Neon
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id                String    @id @default(cuid())
  username          String    @unique
  email             String    @unique
  password          String // Remember to hash in a real app!
  profilePictureUrl String?
  bannerImageUrl    String?
  bio               String?
  themePreference   String?   @default("system") // 'light', 'dark', 'system'
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  posts             Post[]             @relation("UserPosts")
  identitiesOwned   Identity[]         @relation("OwnedIdentities")
  teamMemberships   TeamMember[]       @relation("UserTeamMemberships")
  comments          Comment[]          @relation("UserComments")
  reactions         Reaction[]         @relation("UserReactions")
  notificationsSent Notification[]     @relation("ActorNotifications")
  notificationsRecv Notification[]     @relation("RecipientNotifications")
  sportInterests    SportInterest[]
  socialLinks       SocialLink[]       @relation("UserSocialLinks")
  playerChatMessages PlayerChatMessage[] @relation("UserPlayerChatMessages")
  blogs             Blog[]             @relation("UserBlogs")
}

model Identity {
  id                String    @id @default(cuid())
  username          String    @unique
  displayName       String?
  email             String?   @unique
  profilePictureUrl String?
  bannerImageUrl    String?
  bio               String?
  themePreference   String?   @default("system")
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  ownerId           String
  owner             User      @relation("OwnedIdentities", fields: [ownerId], references: [id])

  posts             Post[]             @relation("IdentityPosts")
  teamMembers       TeamMember[]       @relation("IdentityTeamMembers")
  comments          Comment[]          @relation("IdentityComments")
  reactions         Reaction[]         @relation("IdentityReactions")
  notificationsSent Notification[]     @relation("IdentityActorNotifications")
  socialLinks       SocialLink[]       @relation("IdentitySocialLinks")
  playerChatMessages PlayerChatMessage[] @relation("IdentityPlayerChatMessages")
  blogs             Blog[]             @relation("IdentityBlogs")
}

model TeamMember {
  id          String   @id @default(cuid())
  permissions String[] // e.g., ["can_post_blogs", "can_edit_profile"]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  identityId  String
  identity    Identity @relation("IdentityTeamMembers", fields: [identityId], references: [id])
  userId      String
  user        User     @relation("UserTeamMemberships", fields: [userId], references: [id])

  @@unique([identityId, userId])
}

model SportInterest {
  id     String @id @default(cuid())
  sport  String
  level  String // 'very interested', 'somewhat interested', 'no interest'
  userId String
  user   User   @relation(fields: [userId], references: [id])

  @@unique([userId, sport])
}

model SocialLink {
  id         String  @id @default(cuid())
  platform   String
  url        String
  userId     String?
  user       User?   @relation("UserSocialLinks", fields: [userId], references: [id])
  identityId String?
  identity   Identity? @relation("IdentitySocialLinks", fields: [identityId], references: [id])
}

model Post {
  id        String   @id @default(cuid())
  content   String? // Optional if it's purely a share
  mediaUrl  String?
  mediaType String?  // 'image', 'gif'
  tags      String[] @default([])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorUserId      String?
  authorUser        User?    @relation("UserPosts", fields: [authorUserId], references: [id])
  authorIdentityId  String?
  authorIdentity    Identity? @relation("IdentityPosts", fields: [authorIdentityId], references: [id])

  sharedOriginalPostId String?
  sharedOriginalPost   Post?   @relation("SharedPosts", fields: [sharedOriginalPostId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  shares               Post[]  @relation("SharedPosts")

  comments          Comment[]
  reactions         Reaction[]
  notifications     Notification[] @relation("PostNotifications")

  @@index([authorUserId])
  @@index([authorIdentityId])
  @@index([sharedOriginalPostId])
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  postId    String
  post      Post     @relation(fields: [postId], references: [id])

  authorUserId     String?
  authorUser       User?    @relation("UserComments", fields: [authorUserId], references: [id])
  authorIdentityId String?
  authorIdentity   Identity? @relation("IdentityComments", fields: [authorIdentityId], references: [id])

  parentId  String?
  parent    Comment? @relation("Replies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies   Comment[] @relation("Replies")

  reactions         Reaction[]
  notifications     Notification[] @relation("CommentNotifications")
  originalCommentNotifications Notification[] @relation("OriginalCommentNotifications")


  @@index([postId])
  @@index([authorUserId])
  @@index([authorIdentityId])
  @@index([parentId])
}

enum ReactionTypeValue {
  LIKE
  LOVE
  HAHA
  WOW
  SAD
  ANGRY
}

model Reaction {
  id        String   @id @default(cuid())
  type      ReactionTypeValue
  createdAt DateTime @default(now())

  userId           String?
  user             User?    @relation("UserReactions", fields: [userId], references: [id])
  identityId       String?
  identity         Identity? @relation("IdentityReactions", fields: [identityId], references: [id])

  postId    String?
  post      Post?    @relation(fields: [postId], references: [id])
  commentId String?
  comment   Comment? @relation(fields: [commentId], references: [id])

  @@unique([userId, postId, type]) // User can only have one type of reaction per post
  @@unique([userId, commentId, type]) // User can only have one type of reaction per comment
  @@unique([identityId, postId, type])
  @@unique([identityId, commentId, type])
  @@index([postId])
  @@index([commentId])
  @@index([userId])
  @@index([identityId])
}

enum NotificationTypeValue {
  NEW_REACTION_POST
  NEW_COMMENT
  NEW_REPLY
  NEW_REACTION_COMMENT
  // Add other types as needed: NEW_FOLLOWER, MENTION, etc.
}

model Notification {
  id        String   @id @default(cuid())
  type      NotificationTypeValue
  link      String?
  createdAt DateTime @default(now())
  isRead    Boolean  @default(false)

  actorUserId      String?
  actorUser        User?    @relation("ActorNotifications", fields: [actorUserId], references: [id])
  actorIdentityId  String?
  actorIdentity    Identity? @relation("IdentityActorNotifications", fields: [actorIdentityId], references: [id])

  recipientId      String
  recipient        User     @relation("RecipientNotifications", fields: [recipientId], references: [id])

  postId    String?
  post      Post?    @relation("PostNotifications", fields: [postId], references: [id])
  commentId String?
  comment   Comment? @relation("CommentNotifications", fields: [commentId], references: [id])
  originalCommentId String? // For replies, the ID of the comment being replied to
  originalComment   Comment? @relation("OriginalCommentNotifications", fields: [originalCommentId], references: [id])

  @@index([recipientId])
}

model Player {
  id                 String   @id @default(cuid())
  name               String
  sport              String // e.g., "Basketball", "Football"
  profilePictureUrl  String?
  team               String?
  position           String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  chatMessages PlayerChatMessage[]

  @@unique([name, sport])
}

model PlayerChatMessage {
  id        String   @id @default(cuid())
  message   String
  createdAt DateTime @default(now())

  playerId String
  player   Player @relation(fields: [playerId], references: [id])

  authorUserId     String?
  authorUser       User?    @relation("UserPlayerChatMessages", fields: [authorUserId], references: [id])
  authorIdentityId String?
  authorIdentity   Identity? @relation("IdentityPlayerChatMessages", fields: [authorIdentityId], references: [id])

  @@index([playerId])
}

model Blog {
  id            String   @id @default(cuid())
  title         String
  slug          String   @unique
  content       String
  excerpt       String?
  coverImageUrl String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  authorUserId     String?
  authorUser       User?    @relation("UserBlogs", fields: [authorUserId], references: [id])
  authorIdentityId String?
  authorIdentity   Identity? @relation("IdentityBlogs", fields: [authorIdentityId], references: [id])
}

// For NextAuth.js Adapter (Optional, but good practice if using Prisma Adapter)
// model Account {
//   id                String  @id @default(cuid())
//   userId            String
//   type              String
//   provider          String
//   providerAccountId String
//   refresh_token     String? @db.Text
//   access_token      String? @db.Text
//   expires_at        Int?
//   token_type        String?
//   scope             String?
//   id_token          String? @db.Text
//   session_state     String?

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@unique([provider, providerAccountId])
// }

// model Session {
//   id           String   @id @default(cuid())
//   sessionToken String   @unique
//   userId       String
//   expires      DateTime
//   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
// }

// model VerificationToken {
//   identifier String
//   token      String   @unique
//   expires    DateTime

//   @@unique([identifier, token])
// }